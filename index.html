<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Mini MMORPG</title>
    <link
      rel="stylesheet"
      href="styles.css"
    />
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game state
      let gameState = {
        playerId: null,
        players: {},
        avatars: {},
        worldImage: null,
        viewport: { x: 0, y: 0 }, // Top-left corner of viewport in world coordinates
        isConnected: false,
      };

      const WORLD_SIZE = 2048;
      const USERNAME = "Deep";

      // Avatar bounding box - standardized size for all avatars
      const AVATAR_BBOX = {
        width: 64, // Fixed width for collision/boundary detection
        height: 64, // Fixed height for collision/boundary detection
        offsetX: 32, // Half width - centers the bbox on player position
        offsetY: 32, // Half height - centers the bbox on player position
      };

      // Keyboard state for movement
      let pressedKeys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
      };

      // WebSocket connection
      let ws = null;

      // Set canvas size to fill the window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        updateViewport();
        draw();
      }

      // Connect to game server
      function connectToServer() {
        ws = new WebSocket("wss://codepath-mmorg.onrender.com");

        ws.onopen = function () {
          console.log("Connected to game server");
          // Send join game message
          const joinMessage = {
            action: "join_game",
            username: USERNAME,
          };
          ws.send(JSON.stringify(joinMessage));
        };

        ws.onmessage = function (event) {
          const message = JSON.parse(event.data);
          handleServerMessage(message);
        };

        ws.onclose = function () {
          console.log("Disconnected from game server");
          gameState.isConnected = false;
        };

        ws.onerror = function (error) {
          console.error("WebSocket error:", error);
        };
      }

      // Handle messages from server
      function handleServerMessage(message) {
        switch (message.action) {
          case "join_game":
            if (message.success) {
              gameState.playerId = message.playerId;
              gameState.players = message.players;
              gameState.avatars = message.avatars;
              gameState.isConnected = true;
              console.log("Joined game with player ID:", gameState.playerId);
              console.log(
                "Player position:",
                gameState.players[gameState.playerId]
              );
              loadAvatarImages();
              // Ensure canvas is properly sized before updating viewport
              resizeCanvas();
            } else {
              console.error("Failed to join game:", message.error);
            }
            break;
          case "players_moved":
            // Update player positions
            Object.assign(gameState.players, message.players);
            // Update viewport if our player moved
            if (message.players[gameState.playerId]) {
              updateViewport();
            }
            draw();
            break;
          case "player_joined":
            gameState.players[message.player.id] = message.player;
            if (message.avatar) {
              gameState.avatars[message.avatar.name] = message.avatar;
              loadAvatarImages();
            }
            draw();
            break;
          case "player_left":
            delete gameState.players[message.playerId];
            draw();
            break;
          default:
            console.log("Unknown message:", message);
        }
      }

      // Send movement command to server
      function sendMoveCommand(direction) {
        if (ws && ws.readyState === WebSocket.OPEN && gameState.isConnected) {
          const moveMessage = {
            action: "move",
            direction: direction,
          };
          ws.send(JSON.stringify(moveMessage));
          console.log("Sent move command:", direction);
        }
      }

      // Send stop command to server
      function sendStopCommand() {
        if (ws && ws.readyState === WebSocket.OPEN && gameState.isConnected) {
          const stopMessage = {
            action: "stop",
          };
          ws.send(JSON.stringify(stopMessage));
          console.log("Sent stop command");
        }
      }

      // Check if avatar is in danger zone (near world boundaries)
      function isInDangerZone(player) {
        const dangerMargin = 100; // Distance from edge to start showing danger

        // Calculate avatar bounds
        const avatarLeft = player.x - AVATAR_BBOX.offsetX;
        const avatarRight = player.x + AVATAR_BBOX.offsetX;
        const avatarTop = player.y - AVATAR_BBOX.offsetY;
        const avatarBottom = player.y + AVATAR_BBOX.offsetY;

        // Check if avatar is near any world boundary
        return (
          avatarLeft <= dangerMargin || // Near left edge
          avatarRight >= WORLD_SIZE - dangerMargin || // Near right edge
          avatarTop <= dangerMargin || // Near top edge
          avatarBottom >= WORLD_SIZE - dangerMargin // Near bottom edge
        );
      }

      // Get avatar bounding box in world coordinates
      function getAvatarBounds(player) {
        return {
          left: player.x - AVATAR_BBOX.offsetX,
          right: player.x + AVATAR_BBOX.offsetX,
          top: player.y - AVATAR_BBOX.offsetY,
          bottom: player.y + AVATAR_BBOX.offsetY,
          centerX: player.x,
          centerY: player.y,
        };
      }

      // Load avatar images from base64 data
      function loadAvatarImages() {
        for (const avatarName in gameState.avatars) {
          const avatar = gameState.avatars[avatarName];
          avatar.loadedImages = {};

          for (const direction in avatar.frames) {
            avatar.loadedImages[direction] = [];
            avatar.frames[direction].forEach((base64Data, index) => {
              const img = new Image();
              img.onload = function () {
                avatar.loadedImages[direction][index] = img;
                draw(); // Redraw when image loads
              };
              img.src = base64Data;
            });
          }
        }
      }

      // Update viewport to keep player visible with dead zone
      function updateViewport() {
        if (!gameState.playerId || !gameState.players[gameState.playerId]) {
          return;
        }

        const player = gameState.players[gameState.playerId];
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        // Dead zone - area where player can move without camera following
        const deadZoneWidth = Math.min(100, canvasWidth * 0.1); // 10% of screen or 100px max
        const deadZoneHeight = Math.min(100, canvasHeight * 0.1);

        // Current player position on screen
        const screenX = player.x - gameState.viewport.x;
        const screenY = player.y - gameState.viewport.y;

        // Target viewport position (start with current)
        let newViewportX = gameState.viewport.x;
        let newViewportY = gameState.viewport.y;

        // Check if player is outside the dead zone and adjust camera
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;

        // Horizontal dead zone check
        if (screenX < centerX - deadZoneWidth) {
          // Player too far left, move camera left
          newViewportX = player.x - (centerX - deadZoneWidth);
        } else if (screenX > centerX + deadZoneWidth) {
          // Player too far right, move camera right
          newViewportX = player.x - (centerX + deadZoneWidth);
        }

        // Vertical dead zone check
        if (screenY < centerY - deadZoneHeight) {
          // Player too far up, move camera up
          newViewportY = player.y - (centerY - deadZoneHeight);
        } else if (screenY > centerY + deadZoneHeight) {
          // Player too far down, move camera down
          newViewportY = player.y - (centerY + deadZoneHeight);
        }

        // Clamp viewport to world boundaries
        newViewportX = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasWidth, newViewportX)
        );
        newViewportY = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasHeight, newViewportY)
        );

        // Ensure avatar bounding box is always visible (priority over centering)
        const avatarBounds = getAvatarBounds(player);
        const margin = 20; // Minimum margin from screen edge

        const minViewportX = avatarBounds.right - canvasWidth + margin; // Keep avatar right edge visible
        const maxViewportX = avatarBounds.left - margin; // Keep avatar left edge visible
        const minViewportY = avatarBounds.bottom - canvasHeight + margin; // Keep avatar bottom edge visible
        const maxViewportY = avatarBounds.top - margin; // Keep avatar top edge visible

        newViewportX = Math.max(
          minViewportX,
          Math.min(maxViewportX, newViewportX)
        );
        newViewportY = Math.max(
          minViewportY,
          Math.min(maxViewportY, newViewportY)
        );

        // Final clamp to world boundaries
        newViewportX = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasWidth, newViewportX)
        );
        newViewportY = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasHeight, newViewportY)
        );

        // Calculate final player screen position for debugging
        const finalScreenX = player.x - newViewportX;
        const finalScreenY = player.y - newViewportY;

        console.log(
          `Camera: player world(${player.x}, ${player.y}) screen(${finalScreenX}, ${finalScreenY}) viewport(${newViewportX}, ${newViewportY}) canvas(${canvasWidth}x${canvasHeight})`
        );

        gameState.viewport.x = newViewportX;
        gameState.viewport.y = newViewportY;
      }

      // Convert world coordinates to screen coordinates
      function worldToScreen(worldX, worldY) {
        return {
          x: worldX - gameState.viewport.x,
          y: worldY - gameState.viewport.y,
        };
      }

      // Load and draw the world map
      function loadWorldImage() {
        const worldImage = new Image();
        worldImage.onload = function () {
          gameState.worldImage = worldImage;
          draw();
        };
        worldImage.src = "world.jpg";
      }

      // Main drawing function
      function draw() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw world map
        if (gameState.worldImage) {
          ctx.drawImage(
            gameState.worldImage,
            gameState.viewport.x,
            gameState.viewport.y,
            canvas.width,
            canvas.height,
            0,
            0,
            canvas.width,
            canvas.height
          );
        }

        // Draw danger zone overlay if player is near boundaries
        drawDangerZone();

        // Draw players
        drawPlayers();
      }

      // Draw danger zone overlay
      function drawDangerZone() {
        if (!gameState.playerId || !gameState.players[gameState.playerId]) {
          return;
        }

        const player = gameState.players[gameState.playerId];

        if (isInDangerZone(player)) {
          // Create pulsing red overlay effect
          const time = Date.now() / 300; // Speed of pulsing
          const alpha = 0.1 + 0.05 * Math.sin(time); // Pulse between 0.1 and 0.15

          ctx.save();
          ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Add border warning
          ctx.strokeStyle = `rgba(255, 0, 0, ${alpha * 2})`;
          ctx.lineWidth = 10;
          ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

          ctx.restore();
        }
      }

      // Draw all players and their avatars
      function drawPlayers() {
        for (const playerId in gameState.players) {
          const player = gameState.players[playerId];
          drawPlayer(player);
        }
      }

      // Draw individual player
      function drawPlayer(player) {
        const avatar = gameState.avatars[player.avatar];
        if (!avatar || !avatar.loadedImages) return;

        const screenPos = worldToScreen(player.x, player.y);

        // Get the appropriate avatar image
        let direction = player.facing;
        if (direction === "west") {
          direction = "east"; // We'll flip east frames for west
        }

        const frames = avatar.loadedImages[direction];
        if (!frames || frames.length === 0) return;

        const frameIndex = player.animationFrame || 0;
        const avatarImage = frames[frameIndex];
        if (!avatarImage) return;

        // Calculate avatar position (center the avatar on the player position)
        const avatarX = screenPos.x - avatarImage.width / 2;
        const avatarY = screenPos.y - avatarImage.height / 2;

        // Save context for potential flipping
        ctx.save();

        // Flip horizontally for west direction
        if (player.facing === "west") {
          ctx.scale(-1, 1);
          ctx.drawImage(avatarImage, -avatarX - avatarImage.width, avatarY);
        } else {
          ctx.drawImage(avatarImage, avatarX, avatarY);
        }

        ctx.restore();

        // Draw username label
        drawUsernameLabel(player, screenPos);

        // Draw bounding box for our own player only when in danger zone
        if (player.id === gameState.playerId && isInDangerZone(player)) {
          drawAvatarBoundingBox(player, screenPos);
        }
      }

      // Draw username label above avatar
      function drawUsernameLabel(player, screenPos) {
        ctx.save();
        ctx.font = "14px Arial";
        ctx.fillStyle = "white";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.textAlign = "center";

        const labelY = screenPos.y - 40; // Position above avatar

        // Draw text with outline
        ctx.strokeText(player.username, screenPos.x, labelY);
        ctx.fillText(player.username, screenPos.x, labelY);

        ctx.restore();
      }

      // Draw avatar bounding box (debug visualization)
      function drawAvatarBoundingBox(player, screenPos) {
        ctx.save();
        ctx.strokeStyle = "rgba(0, 255, 0, 0.7)"; // Semi-transparent green
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // Dashed line

        const bboxX = screenPos.x - AVATAR_BBOX.offsetX;
        const bboxY = screenPos.y - AVATAR_BBOX.offsetY;

        ctx.strokeRect(bboxX, bboxY, AVATAR_BBOX.width, AVATAR_BBOX.height);

        // Draw center point
        ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
        ctx.fillRect(screenPos.x - 2, screenPos.y - 2, 4, 4);

        ctx.restore();
      }

      // Handle keyboard input for movement
      function handleKeyDown(event) {
        // Prevent arrow keys from scrolling the page
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
            event.code
          )
        ) {
          event.preventDefault();
        }

        // Only send move command if key wasn't already pressed
        if (!pressedKeys[event.code] && gameState.isConnected) {
          pressedKeys[event.code] = true;

          // Map arrow keys to movement directions
          switch (event.code) {
            case "ArrowUp":
              sendMoveCommand("up");
              break;
            case "ArrowDown":
              sendMoveCommand("down");
              break;
            case "ArrowLeft":
              sendMoveCommand("left");
              break;
            case "ArrowRight":
              sendMoveCommand("right");
              break;
          }
        }
      }

      function handleKeyUp(event) {
        // Only send stop command if key was actually pressed
        if (pressedKeys[event.code] && gameState.isConnected) {
          pressedKeys[event.code] = false;

          // Send stop command when releasing any arrow key
          if (
            ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
              event.code
            )
          ) {
            sendStopCommand();
          }
        }
      }

      // Reset all keys when window loses focus
      function handleWindowBlur() {
        // Reset all pressed keys
        for (let key in pressedKeys) {
          pressedKeys[key] = false;
        }
        // Send stop command to ensure player stops moving
        if (gameState.isConnected) {
          sendStopCommand();
        }
      }

      // Initialize the game
      function init() {
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        // Set up keyboard event listeners
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);
        window.addEventListener("blur", handleWindowBlur);

        loadWorldImage();
        connectToServer();
      }

      // Start the game when the page loads
      window.addEventListener("load", init);
    </script>
  </body>
</html>

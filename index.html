<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Mini MMORPG</title>
    <link
      rel="stylesheet"
      href="styles.css"
    />
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>

    <!-- Game UI Overlay -->
    <div id="gameUI">
      <!-- UI Toggle Button -->
      <button
        id="uiToggleBtn"
        class="ui-toggle-button"
        title="Toggle UI (H key)"
      >
        <span class="toggle-icon">üëÅÔ∏è</span>
      </button>

      <!-- UI Container for all panels -->
      <div
        id="uiContainer"
        class="ui-container"
      >
        <div
          id="statusPanel"
          class="ui-panel adaptive-panel"
          data-position="top-left"
        >
          <div class="panel-title">Game Status</div>
          <div class="status-item">
            <span class="status-label">Connection:</span>
            <span
              id="connectionStatus"
              class="status-value"
              >Connecting...</span
            >
            <span
              id="connectionDot"
              class="connection-dot connecting"
            ></span>
          </div>
          <div class="status-item">
            <span class="status-label">Player:</span>
            <span
              id="playerInfo"
              class="status-value"
              >-</span
            >
          </div>
          <div class="status-item">
            <span class="status-label">Position:</span>
            <span
              id="playerPosition"
              class="status-value"
              >-</span
            >
          </div>
          <div class="status-item">
            <span class="status-label">Players Online:</span>
            <span
              id="playerCount"
              class="status-value"
              >-</span
            >
          </div>
        </div>

        <!-- Player List Panel (top-right) -->
        <div
          id="playerListPanel"
          class="ui-panel adaptive-panel"
          data-position="top-right"
        >
          <div class="panel-title">Players Online</div>
          <div
            id="playerList"
            class="player-list"
          >
            <div class="player-list-item loading">
              <span>Loading players...</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game state
      let gameState = {
        playerId: null,
        players: {},
        avatars: {},
        worldImage: null,
        viewport: { x: 0, y: 0 }, // Top-left corner of viewport in world coordinates
        isConnected: false,
      };

      const WORLD_SIZE = 2048;
      const USERNAME = "Deep";

      // Avatar bounding box - standardized size for all avatars
      const AVATAR_BBOX = {
        width: 64, // Fixed width for collision/boundary detection
        height: 64, // Fixed height for collision/boundary detection
        offsetX: 32, // Half width - centers the bbox on player position
        offsetY: 32, // Half height - centers the bbox on player position
      };

      // Keyboard state for movement
      let pressedKeys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
      };

      // WebSocket connection
      let ws = null;

      // UI Elements
      const uiElements = {
        connectionStatus: document.getElementById("connectionStatus"),
        connectionDot: document.getElementById("connectionDot"),
        playerInfo: document.getElementById("playerInfo"),
        playerPosition: document.getElementById("playerPosition"),
        playerCount: document.getElementById("playerCount"),
        toggleButton: document.getElementById("uiToggleBtn"),
        uiContainer: document.getElementById("uiContainer"),
        statusPanel: document.getElementById("statusPanel"),
        playerListPanel: document.getElementById("playerListPanel"),
        playerList: document.getElementById("playerList"),
      };

      // UI State
      let uiState = {
        isVisible: true,
        panels: {
          statusPanel: {
            element: null,
            currentPosition: "top-left",
            defaultPosition: "top-left",
            alternatePosition: "top-right",
          },
          playerListPanel: {
            element: null,
            currentPosition: "top-right",
            defaultPosition: "top-right",
            alternatePosition: "bottom-right",
          },
        },
      };

      // Set canvas size to fill the window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        updateViewport();
        draw();
      }

      // Connect to game server
      function connectToServer() {
        updateConnectionStatus("connecting");

        ws = new WebSocket("wss://codepath-mmorg.onrender.com");

        ws.onopen = function () {
          console.log("Connected to game server");
          updateConnectionStatus("connected");
          // Send join game message
          const joinMessage = {
            action: "join_game",
            username: USERNAME,
          };
          ws.send(JSON.stringify(joinMessage));
        };

        ws.onmessage = function (event) {
          const message = JSON.parse(event.data);
          handleServerMessage(message);
        };

        ws.onclose = function () {
          console.log("Disconnected from game server");
          gameState.isConnected = false;
          updateConnectionStatus("disconnected");
        };

        ws.onerror = function (error) {
          console.error("WebSocket error:", error);
          updateConnectionStatus("disconnected");
        };
      }

      // Handle messages from server
      function handleServerMessage(message) {
        switch (message.action) {
          case "join_game":
            if (message.success) {
              gameState.playerId = message.playerId;
              gameState.players = message.players;
              gameState.avatars = message.avatars;
              gameState.isConnected = true;
              console.log("Joined game with player ID:", gameState.playerId);
              console.log(
                "Player position:",
                gameState.players[gameState.playerId]
              );
              loadAvatarImages();
              updateAllUI();
              // Ensure canvas is properly sized before updating viewport
              resizeCanvas();
            } else {
              console.error("Failed to join game:", message.error);
            }
            break;
          case "players_moved":
            // Update player positions
            Object.assign(gameState.players, message.players);
            // Update viewport if our player moved
            if (message.players[gameState.playerId]) {
              updateViewport();
              updatePlayerPosition(); // Update position in UI
            }
            updatePlayerCount(); // Update player count in case someone left
            draw();
            break;
          case "player_joined":
            gameState.players[message.player.id] = message.player;
            if (message.avatar) {
              gameState.avatars[message.avatar.name] = message.avatar;
              loadAvatarImages();
            }
            updatePlayerCount();
            draw();
            break;
          case "player_left":
            delete gameState.players[message.playerId];
            updatePlayerCount();
            draw();
            break;
          default:
            console.log("Unknown message:", message);
        }
      }

      // Send movement command to server
      function sendMoveCommand(direction) {
        if (ws && ws.readyState === WebSocket.OPEN && gameState.isConnected) {
          const moveMessage = {
            action: "move",
            direction: direction,
          };
          ws.send(JSON.stringify(moveMessage));
          console.log("Sent move command:", direction);
        }
      }

      // Send stop command to server
      function sendStopCommand() {
        if (ws && ws.readyState === WebSocket.OPEN && gameState.isConnected) {
          const stopMessage = {
            action: "stop",
          };
          ws.send(JSON.stringify(stopMessage));
          console.log("Sent stop command");
        }
      }

      // Check if avatar is in danger zone (near world boundaries)
      function isInDangerZone(player) {
        const dangerMargin = 100; // Distance from edge to start showing danger

        // Calculate avatar bounds
        const avatarLeft = player.x - AVATAR_BBOX.offsetX;
        const avatarRight = player.x + AVATAR_BBOX.offsetX;
        const avatarTop = player.y - AVATAR_BBOX.offsetY;
        const avatarBottom = player.y + AVATAR_BBOX.offsetY;

        // Check if avatar is near any world boundary
        return (
          avatarLeft <= dangerMargin || // Near left edge
          avatarRight >= WORLD_SIZE - dangerMargin || // Near right edge
          avatarTop <= dangerMargin || // Near top edge
          avatarBottom >= WORLD_SIZE - dangerMargin // Near bottom edge
        );
      }

      // Get avatar bounding box in world coordinates
      function getAvatarBounds(player) {
        return {
          left: player.x - AVATAR_BBOX.offsetX,
          right: player.x + AVATAR_BBOX.offsetX,
          top: player.y - AVATAR_BBOX.offsetY,
          bottom: player.y + AVATAR_BBOX.offsetY,
          centerX: player.x,
          centerY: player.y,
        };
      }

      // Update UI elements
      function updateConnectionStatus(status) {
        const statusText = {
          connecting: "Connecting...",
          connected: "Connected",
          disconnected: "Disconnected",
        };

        uiElements.connectionStatus.textContent =
          statusText[status] || "Unknown";
        uiElements.connectionDot.className = `connection-dot ${status}`;
      }

      function updatePlayerInfo() {
        if (gameState.playerId && gameState.players[gameState.playerId]) {
          const player = gameState.players[gameState.playerId];
          uiElements.playerInfo.textContent = `${
            player.username
          } (${gameState.playerId.substring(0, 8)})`;
        } else {
          uiElements.playerInfo.textContent = "-";
        }
      }

      function updatePlayerPosition() {
        if (gameState.playerId && gameState.players[gameState.playerId]) {
          const player = gameState.players[gameState.playerId];
          uiElements.playerPosition.textContent = `(${Math.round(
            player.x
          )}, ${Math.round(player.y)})`;

          // Check if we need to hide/show panels when position updates
          updateAdaptivePanels();
        } else {
          uiElements.playerPosition.textContent = "-";
        }
      }

      function updatePlayerCount() {
        const count = Object.keys(gameState.players).length;
        uiElements.playerCount.textContent = count > 0 ? count.toString() : "-";
      }

      function updateAllUI() {
        updatePlayerInfo();
        updatePlayerPosition(); // This now calls updateAdaptivePanels()
        updatePlayerCount();
        updatePlayerList();
      }

      // Calculate distance between two points
      function calculateDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // Check if a player is visible on screen
      function isPlayerVisible(player) {
        const screenPos = worldToScreen(player.x, player.y);
        return (
          screenPos.x >= -50 &&
          screenPos.x <= canvas.width + 50 &&
          screenPos.y >= -50 &&
          screenPos.y <= canvas.height + 50
        );
      }

      // Format distance for display
      function formatDistance(distance) {
        if (distance < 1000) {
          return Math.round(distance) + "px";
        } else {
          return (distance / 1000).toFixed(1) + "k";
        }
      }

      // Update the player list
      function updatePlayerList() {
        if (!gameState.playerId || !gameState.players[gameState.playerId]) {
          return;
        }

        const myPlayer = gameState.players[gameState.playerId];
        const playerList = uiElements.playerList;

        // Clear current list
        playerList.innerHTML = "";

        // Create array of all players with distance info
        const playersWithDistance = Object.values(gameState.players).map(
          (player) => {
            const distance =
              player.id === gameState.playerId
                ? 0
                : calculateDistance(myPlayer.x, myPlayer.y, player.x, player.y);

            return {
              ...player,
              distance: distance,
              isVisible: isPlayerVisible(player),
            };
          }
        );

        // Sort by distance (you first, then by distance)
        playersWithDistance.sort((a, b) => {
          if (a.id === gameState.playerId) return -1;
          if (b.id === gameState.playerId) return 1;
          return a.distance - b.distance;
        });

        // Create list items
        playersWithDistance.forEach((player) => {
          const listItem = document.createElement("div");
          listItem.className = `player-list-item ${
            player.id === gameState.playerId ? "you" : ""
          }`;

          const playerName = document.createElement("span");
          playerName.className = "player-name";
          playerName.textContent =
            player.username +
            (player.id === gameState.playerId ? " (you)" : "");

          const playerDistance = document.createElement("span");
          playerDistance.className = "player-distance";
          playerDistance.textContent =
            player.id === gameState.playerId
              ? "-"
              : formatDistance(player.distance);

          const playerStatus = document.createElement("div");
          playerStatus.className = `player-status ${
            player.isVisible ? "visible" : "hidden"
          }`;
          playerStatus.title = player.isVisible
            ? "Visible on screen"
            : "Off screen";

          listItem.appendChild(playerName);
          listItem.appendChild(playerDistance);
          listItem.appendChild(playerStatus);

          playerList.appendChild(listItem);
        });
      }

      // UI Toggle functionality
      function toggleUI() {
        uiState.isVisible = !uiState.isVisible;

        if (uiState.isVisible) {
          uiElements.uiContainer.classList.remove("hidden");
          document.getElementById("gameUI").classList.remove("ui-hidden");
        } else {
          uiElements.uiContainer.classList.add("hidden");
          document.getElementById("gameUI").classList.add("ui-hidden");
        }

        console.log("UI toggled:", uiState.isVisible ? "visible" : "hidden");
      }

      // Hide UI panels when "Deep" avatar gets too close
      function updateAdaptivePanels() {
        if (
          !gameState.playerId ||
          !gameState.players[gameState.playerId] ||
          !uiState.isVisible
        ) {
          return;
        }

        const player = gameState.players[gameState.playerId];

        // Only check for "Deep" player (that's you!)
        if (player.username !== "Deep") {
          return;
        }

        const screenPos = worldToScreen(player.x, player.y);

        // Handle status panel (top-left)
        const statusPanel = uiElements.statusPanel;
        if (statusPanel) {
          const isNearStatusPanel = screenPos.x < 240 && screenPos.y < 180;

          if (isNearStatusPanel) {
            statusPanel.style.opacity = "0";
            statusPanel.style.pointerEvents = "none";
          } else {
            statusPanel.style.opacity = "1";
            statusPanel.style.pointerEvents = "auto";
          }
        }

        // Handle player list panel (top-right)
        const playerListPanel = uiElements.playerListPanel;
        if (playerListPanel) {
          const isNearPlayerList =
            screenPos.x > canvas.width - 280 && screenPos.y < 220;

          if (isNearPlayerList) {
            playerListPanel.style.opacity = "0";
            playerListPanel.style.pointerEvents = "none";
          } else {
            playerListPanel.style.opacity = "1";
            playerListPanel.style.pointerEvents = "auto";
          }
        }
      }

      // Check if avatar position conflicts with a panel position
      function checkPanelCollision(screenPos, panelPosition) {
        const avatarBuffer = 120; // Distance threshold to trigger panel movement

        switch (panelPosition) {
          case "top-left":
            return screenPos.x < avatarBuffer && screenPos.y < avatarBuffer;
          case "top-right":
            return (
              screenPos.x > canvas.width - avatarBuffer &&
              screenPos.y < avatarBuffer
            );
          case "bottom-left":
            return (
              screenPos.x < avatarBuffer &&
              screenPos.y > canvas.height - avatarBuffer
            );
          case "bottom-right":
            return (
              screenPos.x > canvas.width - avatarBuffer &&
              screenPos.y > canvas.height - avatarBuffer
            );
          default:
            return false;
        }
      }

      // Load avatar images from base64 data
      function loadAvatarImages() {
        for (const avatarName in gameState.avatars) {
          const avatar = gameState.avatars[avatarName];
          avatar.loadedImages = {};

          for (const direction in avatar.frames) {
            avatar.loadedImages[direction] = [];
            avatar.frames[direction].forEach((base64Data, index) => {
              const img = new Image();
              img.onload = function () {
                avatar.loadedImages[direction][index] = img;
                draw(); // Redraw when image loads
              };
              img.src = base64Data;
            });
          }
        }
      }

      // Update viewport to keep player visible with dead zone
      function updateViewport() {
        if (!gameState.playerId || !gameState.players[gameState.playerId]) {
          return;
        }

        const player = gameState.players[gameState.playerId];
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        // Dead zone - area where player can move without camera following
        const deadZoneWidth = Math.min(100, canvasWidth * 0.1); // 10% of screen or 100px max
        const deadZoneHeight = Math.min(100, canvasHeight * 0.1);

        // Current player position on screen
        const screenX = player.x - gameState.viewport.x;
        const screenY = player.y - gameState.viewport.y;

        // Target viewport position (start with current)
        let newViewportX = gameState.viewport.x;
        let newViewportY = gameState.viewport.y;

        // Check if player is outside the dead zone and adjust camera
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;

        // Horizontal dead zone check
        if (screenX < centerX - deadZoneWidth) {
          // Player too far left, move camera left
          newViewportX = player.x - (centerX - deadZoneWidth);
        } else if (screenX > centerX + deadZoneWidth) {
          // Player too far right, move camera right
          newViewportX = player.x - (centerX + deadZoneWidth);
        }

        // Vertical dead zone check
        if (screenY < centerY - deadZoneHeight) {
          // Player too far up, move camera up
          newViewportY = player.y - (centerY - deadZoneHeight);
        } else if (screenY > centerY + deadZoneHeight) {
          // Player too far down, move camera down
          newViewportY = player.y - (centerY + deadZoneHeight);
        }

        // Clamp viewport to world boundaries
        newViewportX = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasWidth, newViewportX)
        );
        newViewportY = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasHeight, newViewportY)
        );

        // Ensure avatar bounding box is always visible (priority over centering)
        const avatarBounds = getAvatarBounds(player);
        const margin = 20; // Minimum margin from screen edge

        const minViewportX = avatarBounds.right - canvasWidth + margin; // Keep avatar right edge visible
        const maxViewportX = avatarBounds.left - margin; // Keep avatar left edge visible
        const minViewportY = avatarBounds.bottom - canvasHeight + margin; // Keep avatar bottom edge visible
        const maxViewportY = avatarBounds.top - margin; // Keep avatar top edge visible

        newViewportX = Math.max(
          minViewportX,
          Math.min(maxViewportX, newViewportX)
        );
        newViewportY = Math.max(
          minViewportY,
          Math.min(maxViewportY, newViewportY)
        );

        // Final clamp to world boundaries
        newViewportX = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasWidth, newViewportX)
        );
        newViewportY = Math.max(
          0,
          Math.min(WORLD_SIZE - canvasHeight, newViewportY)
        );

        // Calculate final player screen position for debugging
        const finalScreenX = player.x - newViewportX;
        const finalScreenY = player.y - newViewportY;

        console.log(
          `Camera: player world(${player.x}, ${player.y}) screen(${finalScreenX}, ${finalScreenY}) viewport(${newViewportX}, ${newViewportY}) canvas(${canvasWidth}x${canvasHeight})`
        );

        gameState.viewport.x = newViewportX;
        gameState.viewport.y = newViewportY;
      }

      // Convert world coordinates to screen coordinates
      function worldToScreen(worldX, worldY) {
        return {
          x: worldX - gameState.viewport.x,
          y: worldY - gameState.viewport.y,
        };
      }

      // Load and draw the world map
      function loadWorldImage() {
        const worldImage = new Image();
        worldImage.onload = function () {
          gameState.worldImage = worldImage;
          draw();
        };
        worldImage.src = "world.jpg";
      }

      // Main drawing function
      function draw() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw world map
        if (gameState.worldImage) {
          ctx.drawImage(
            gameState.worldImage,
            gameState.viewport.x,
            gameState.viewport.y,
            canvas.width,
            canvas.height,
            0,
            0,
            canvas.width,
            canvas.height
          );
        }

        // Draw danger zone overlay if player is near boundaries
        drawDangerZone();

        // Draw players
        drawPlayers();
      }

      // Draw danger zone overlay
      function drawDangerZone() {
        if (!gameState.playerId || !gameState.players[gameState.playerId]) {
          return;
        }

        const player = gameState.players[gameState.playerId];

        if (isInDangerZone(player)) {
          // Create pulsing red overlay effect
          const time = Date.now() / 300; // Speed of pulsing
          const alpha = 0.1 + 0.05 * Math.sin(time); // Pulse between 0.1 and 0.15

          ctx.save();
          ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Add border warning
          ctx.strokeStyle = `rgba(255, 0, 0, ${alpha * 2})`;
          ctx.lineWidth = 10;
          ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

          ctx.restore();
        }
      }

      // Draw all players and their avatars
      function drawPlayers() {
        for (const playerId in gameState.players) {
          const player = gameState.players[playerId];
          drawPlayer(player);
        }
      }

      // Draw individual player
      function drawPlayer(player) {
        const avatar = gameState.avatars[player.avatar];
        if (!avatar || !avatar.loadedImages) return;

        const screenPos = worldToScreen(player.x, player.y);

        // Get the appropriate avatar image
        let direction = player.facing;
        if (direction === "west") {
          direction = "east"; // We'll flip east frames for west
        }

        const frames = avatar.loadedImages[direction];
        if (!frames || frames.length === 0) return;

        const frameIndex = player.animationFrame || 0;
        const avatarImage = frames[frameIndex];
        if (!avatarImage) return;

        // Calculate avatar position (center the avatar on the player position)
        const avatarX = screenPos.x - avatarImage.width / 2;
        const avatarY = screenPos.y - avatarImage.height / 2;

        // Save context for potential flipping
        ctx.save();

        // Flip horizontally for west direction
        if (player.facing === "west") {
          ctx.scale(-1, 1);
          ctx.drawImage(avatarImage, -avatarX - avatarImage.width, avatarY);
        } else {
          ctx.drawImage(avatarImage, avatarX, avatarY);
        }

        ctx.restore();

        // Draw username label
        drawUsernameLabel(player, screenPos);

        // Draw bounding box for our own player only when in danger zone
        if (player.id === gameState.playerId && isInDangerZone(player)) {
          drawAvatarBoundingBox(player, screenPos);
        }
      }

      // Draw username label above avatar
      function drawUsernameLabel(player, screenPos) {
        ctx.save();
        ctx.font = "14px Arial";
        ctx.fillStyle = "white";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.textAlign = "center";

        const labelY = screenPos.y - 40; // Position above avatar

        // Draw text with outline
        ctx.strokeText(player.username, screenPos.x, labelY);
        ctx.fillText(player.username, screenPos.x, labelY);

        ctx.restore();
      }

      // Draw avatar bounding box (debug visualization)
      function drawAvatarBoundingBox(player, screenPos) {
        ctx.save();
        ctx.strokeStyle = "rgba(0, 255, 0, 0.7)"; // Semi-transparent green
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // Dashed line

        const bboxX = screenPos.x - AVATAR_BBOX.offsetX;
        const bboxY = screenPos.y - AVATAR_BBOX.offsetY;

        ctx.strokeRect(bboxX, bboxY, AVATAR_BBOX.width, AVATAR_BBOX.height);

        // Draw center point
        ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
        ctx.fillRect(screenPos.x - 2, screenPos.y - 2, 4, 4);

        ctx.restore();
      }

      // Handle keyboard input for movement and UI
      function handleKeyDown(event) {
        // Handle UI toggle with H key
        if (event.code === "KeyH") {
          event.preventDefault();
          toggleUI();
          return;
        }

        // Prevent arrow keys from scrolling the page
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
            event.code
          )
        ) {
          event.preventDefault();
        }

        // Only send move command if key wasn't already pressed
        if (!pressedKeys[event.code] && gameState.isConnected) {
          pressedKeys[event.code] = true;

          // Map arrow keys to movement directions
          switch (event.code) {
            case "ArrowUp":
              sendMoveCommand("up");
              break;
            case "ArrowDown":
              sendMoveCommand("down");
              break;
            case "ArrowLeft":
              sendMoveCommand("left");
              break;
            case "ArrowRight":
              sendMoveCommand("right");
              break;
          }
        }
      }

      function handleKeyUp(event) {
        // Only send stop command if key was actually pressed
        if (pressedKeys[event.code] && gameState.isConnected) {
          pressedKeys[event.code] = false;

          // Send stop command when releasing any arrow key
          if (
            ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
              event.code
            )
          ) {
            sendStopCommand();
          }
        }
      }

      // Reset all keys when window loses focus
      function handleWindowBlur() {
        // Reset all pressed keys
        for (let key in pressedKeys) {
          pressedKeys[key] = false;
        }
        // Send stop command to ensure player stops moving
        if (gameState.isConnected) {
          sendStopCommand();
        }
      }

      // Initialize the game
      function init() {
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        // Set up keyboard event listeners
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);
        window.addEventListener("blur", handleWindowBlur);

        // Set up UI toggle button
        uiElements.toggleButton.addEventListener("click", toggleUI);

        // Initialize UI state
        uiState.panels.statusPanel.element = uiElements.statusPanel;
        uiState.panels.playerListPanel.element = uiElements.playerListPanel;

        loadWorldImage();
        connectToServer();
      }

      // Start the game when the page loads
      window.addEventListener("load", init);
    </script>
  </body>
</html>
